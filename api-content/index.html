{"posts":[{"title":"有限和无限的游戏读后感","content":"《有限与无限的游戏》（Finite and Infinite Games）是詹姆斯·卡斯（James P. Carse）于1986年出版的一本哲学书籍。这本书以一种独特的方式探讨了人生和世界的不同层面，特别是通过“游戏”的隐喻来探讨人类行为和生活方式。 主要内容和观点 有限游戏 vs. 无限游戏 • 有限游戏： • 有明确的开始和结束。 • 参与者在既定的规则下竞争。 • 目标是赢得比赛，赢得胜利意味着游戏的结束。 • 例如：体育比赛、商业竞争、战争等。 • 无限游戏： • 没有固定的规则和时间限制，规则可以随时改变。 • 参与者的目标不是赢得比赛，而是继续游戏，保持游戏的延续。 • 强调的是持续的参与和探索，而非终结。 • 例如：生活本身、文化的发展、创造性的活动等。 游戏的心态 • 卡斯认为，生活中大部分的行为和决策都可以归类为有限游戏或无限游戏。有限游戏的玩家关注的是控制、权力和胜利，而无限游戏的玩家则更关注开放性、可能性和创造性。 规则与自由 • 在有限游戏中，规则是固定的，打破规则即意味着作弊或失败。 • 在无限游戏中，规则可以被改变，玩家有更多的自由去探索新的可能性，创造新的规则。 赢家与输家 • 有限游戏中，赢家和输家是明确的，胜利意味着游戏的终结。 • 无限游戏中，没有最终的赢家或输家，关键在于游戏的持续进行和不断演变。 角色与身份 • 卡斯区分了“角色”和“身份”： • 角色是有限游戏中扮演的特定身份，受制于规则和期望。 • 身份是无限游戏中的自我认知，更加开放和流动。 生命的哲学 • 卡斯通过这些对有限与无限游戏的分析，试图引导读者去反思自己在生活中的选择，是遵循有限游戏的模式，还是追求一种更开放、自由和创造性的无限游戏方式。 总结 《有限与无限的游戏》鼓励读者超越传统的胜负观念，追求一种更具创造性、开放性和持续性的生活方式。它不仅仅是一本哲学书，更是一种生活的指导，提醒我们在面对生活的各种挑战和选择时，可以采取不同的心态和视角。 ","link":"https://DennyWanye.GitHub.io/post/you-xian-he-wu-xian-de-you-xi-du-hou-gan/"},{"title":"升级Node版本：V12->V20/V16->V20","content":"背景 项目上面最近需要将node的版本升级到V20，不过现在项目里面有的用的是V12的node，有的用的是V16的node。 一、利用nvm将项目的node环境转换为20 nvm 是一种很方便管理本地node版本的工具，可以快速的切换本地的node环境。 nvm use 20 二、解决npm i的报错 以下是报错和如何解决的： 报错1： Could not resolve dependency: peer react-dom@&quot;^15.4.2&quot; from react-addons-test-utils@15.6.2 node_modules/react-addons-test-utils dev react-addons-test-utils@&quot;^15.1.0&quot; from the root project 原因： This package is deprecated as of version 15.5.0 TestUtils have been moved to react-dom/test-utils Shallow renderer has been moved to react-test-renderer/shallow 解决： 因为项目里面没有引用，所以删除该包 报错2： Could not resolve dependency: peer webpack@&quot;&gt;=1.12.9 &lt;3.0.0&quot; from babel-plugin-webpack-loaders@0.9.0 node_modules/babel-plugin-webpack-loaders dev babel-plugin-webpack-loaders@&quot;^0.9.0&quot; from the root project 原因： package.json中的webpack版本为3.12.0，而 babel-plugin-webpack-loaders@0.9.0需要的webpack版本为&gt;=1.12.9 ❤️.0.0 解决： 因为babel-plugin-webpack-loaders太旧了停止维护，没有更新的版本，所以只能将webpack降低版本，降低为2.7 报错3： Could not resolve dependency: peer draft-js@&quot;^0.10.x&quot; from react-draft-wysiwyg@1.12.13 node_modules/react-draft-wysiwyg react-draft-wysiwyg@&quot;^1.12.13&quot; from the root project 原因： react-draft-wysiwyg需要的为&quot;draft-js&quot;: &quot;0.10.x”，而package.json中的为&quot;0.11.7&quot; 解决： 因为项目里面没有引用，所以删除该包 报错4： 'darwin-x64' binaries cannot be used on the 'darwin-arm64v8' platform. Please remove the 'node_modules/sharp/vendor' directory and run 'npm install'. 原因： Sharp 需要单独安装适配本机苹果M1芯片的包 解决： 发现关于sharp包的安装问题，在M1芯片的Mac上，需要在安装的时候，利用 npm install --cpu=arm64 --os=darwin sharp 报错5： 关于extract-text-webpack-plugin的版本支持3.0以上的webpack的报错，错误暂时找不到了，跟 报错2类似，而且这个报因为弃用了，所以在npm官网上面搜索不到，我最后是在谷歌搜索里面搜索这个包名称，才找到了之前的地址。 以下是地址：https://www.npmjs.com/package/extract-text-webpack-plugin 建议遇见这种直接利用url规律替换掉包名称进行访问 https://www.npmjs.com/package/包名称 原因： extract-text-webpack-plugin的版本支持3.0以上的webpack 解决： 找到其git链接后，将其降低至对应webpack2.0版本的包 ","link":"https://DennyWanye.GitHub.io/post/sheng-ji-node-ban-ben-v12-greaterv20v16-greaterv20/"},{"title":"记录MongoDB升级 5.0 to 6.0","content":"一、确定MongoDB的升级版本兼容性影响 可以从官网找到： https://www.mongodb.com/zh-cn/docs/manual/release-notes/6.0-compatibility/ 先看一遍，在结合本地代码了解需要处理的错误： 像是这次需要处理的代码如下： not support options: usecreateindex, usefindandmodify, autoreconnect reconnectinterval, reconnecttries 关注带有 $regex 查询的功能， test case 要包含这类功能 删除的操作符 已删除参数 --tlsFIPSMode 弃用 db.collection.reIndex() 检查 accumulator、accumulator、accumulator、function 和 $where 表达式中已删除字符串和数组函数 检查 expireAfterSeconds 设为 NaN 的 TTL index //查询 TTL Non index 的脚本 function getNaNIndexes() { const nan_index = []; const dbs = db.adminCommand({ listDatabases: 1 }).databases; dbs.forEach((d) =&gt; { if (d.name != 'local') { const listCollCursor = db .getSiblingDB(d.name) .runCommand({ listCollections: 1 }).cursor; const collDetails = { db: listCollCursor.ns.split(&quot;.$cmd&quot;)[0], colls: listCollCursor.firstBatch.map((c) =&gt; c.name), }; collDetails.colls.forEach((c) =&gt; db .getSiblingDB(collDetails.db) .getCollection(c) .getIndexes() .forEach((entry) =&gt; { if (Object.is(entry.expireAfterSeconds, NaN)) { nan_index.push({ ns: `${collDetails.db}.${c}`, index: entry }); } }) ); } }); return nan_index; }; getNaNIndexes(); 二、根据上面做出来的信息，对本地代码作出修改 这一步，主要是根据第一步整理出来的信息做代码检查和修改，确定本地的代码已经做了第一步的兼容性处理。 三、将本地的项目连接上6.0版本的MongoDB数据库，运行并解决报错 这一步，直接在本地项目上面链接6.0版本的数据库，很幸运，没有出现很难解决的报错。 ","link":"https://DennyWanye.GitHub.io/post/ji-lu-mongodb-sheng-ji-50-to-60/"},{"title":"Expo Realm 数据库操作","content":"一、读取操作 用 useQuery 的方法： export type RealmQuerySearchText = { searchKey: string, searchValue: any, } export const useQueryN = (flag: flag, searchParams?: RealmQuerySearchText | undefined) =&gt; { return useQuery(flag, item =&gt; { if (searchParams) { return item.filtered(searchParams.searchKey + ' TEXT $0', searchParams.searchValue) } else { return item } }); } 用 useObject的方法没有成功过，不知道怎么传递 _id 数据，不过以下是用 realm.object方法的示例。 await realm .objects(UserData) //UserData 是 schema .filtered(`userId == $0`, userId) 二、写入操作 利用 realm.write : 第一种方式： //timelinesBeforeSort的schema 中 包含了 events的schema，是以List的方式包含的 //events必须是一个全新的对象（对于events的主键来说，也就是主键需要新建，不能存在 //这也就意味着不能用这种方法将已经存在的events 链接到 timelinesBeforeSort的schema上 await realm.write(() =&gt; { timelinesBeforeSort.events = [...timelinesBeforeSort.events, { _id: new BSON.ObjectId(), what: what, why: why || '', how: how || '', start: start, end: end, who: [...who], where: [...where], }] }) ","link":"https://DennyWanye.GitHub.io/post/expo-realm-shu-ju-ku-cao-zuo/"},{"title":"Expo Realm 配置本地和远端的数据库进行同步","content":"开始之前 创建一个AppService，并开启同步（注意查看一下提示注意项） 这个一步需要在官网进行操作： 当然你需要先在官网创建一个DB 和APP Service。 注意1: 第一次使用请注意将接受匿名链接开启，否则，你很难连上，可以后续按照你的需要进行增加权限验证功能： 注意2: 将如果你提示IP Address限制访问的问题，请直接添加一下规则到Network Access中，代表允许任意IP进行访问： 在后端启用 Flexible Sync。您必须在后端配置 Flexible Sync，然后才能在客户端应用程序中使用： https://www.mongodb.com/zh-cn/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-flexible-sync 初始化应用客户端 doc: https://www.mongodb.com/zh-cn/docs/atlas/device-sdks/sdk/react-native/app-services/connect-to-app-services-app/#std-label-react-native-connect-to-mongodb-realm-backend-app 此步骤的目的是为了让localApp和远程创建的app进行访问： 以下为代码： import React from 'react'; import {AppProvider, UserProvider, RealmProvider} from '@realm/react'; function AppWrapperSync() { return ( &lt;AppProvider id={APP_ID}&gt; //1. 输入AppID &lt;UserProvider fallback={LogIn}&gt; //2.利用UserProvider，fallback进行登录验证，建议一开始使用匿名登录，使用匿名登录需要确认一下 注意1 的设置 &lt;RealmProvider //此处设置 sync 对象的 flexible: true， 代表进行同步。 schema={[YourObjectModel]} sync={syncConfigWithErrorHandling}&gt; &lt;RestOfApp /&gt; &lt;/RealmProvider&gt; &lt;/UserProvider&gt; &lt;/AppProvider&gt; ); } //处理如果同步远端realm失败的情况，作用，同步失败的报错信息影响用户体验 const syncConfigWithErrorHandling: any = { flexible: true, //设置为true，开启同步 onError: (_session: any, error: any) =&gt; { //处理报错情况，感觉忽略就好 console.log(_session) console.log(error); }, //用于给remote初始化schemas // initialSubscriptions: { // update(subs, realm) { // subs.add(realm.objects(schemas)); // }, // } newRealmFileBehavior: realmAccessBehavior, //用于处理离线时，同步失败的情况 existingRealmFileBehavior: realmAccessBehavior, //用于处理离线时，同步失败的情况 } //此为在如果项目离线时，同步的设置，专门针对app离线时候的处理：https://www.mongodb.com/zh-cn/docs/atlas/device-sdks/sdk/react-native/sync-data/configure-a-synced-realm/#access-a-synced-realm-while-offline const realmAccessBehavior: Realm.OpenRealmBehaviorConfiguration = { //type: Realm.OpenRealmBehaviorType.OpenImmediately, //@ts-ignore type: 'downloadBeforeOpen', //https://www.mongodb.com/docs/realm-sdks/react/latest/enums/Realm.OpenRealmBehaviorType.html //@ts-ignore timeOutBehavior: 'openLocalRealm', //https://www.mongodb.com/docs/realm-sdks/react/latest/enums/Realm.OpenRealmTimeOutBehavior.html timeOut: 1000, }; 对客户端项目中的用户进行身份验证： Login的代码逻辑，可以使用API Key，邮箱/密码等，但是国内网络原因且只是测试，所以使用匿名登录， 注意1 import { View, Text } from 'react-native'; import { useEffect } from 'react' import { useAuth } from '@realm/react'; const LogIn = () =&gt; { // `logInWithAnonymous` logs in a user using an // anonymous Realm Credential. // `result` gives us access to the result of the // current operation. In this case, `logInWithAnonymous`. const { logInWithAnonymous, result } = useAuth(); //直接利用logInWithAnonymous来进行匿名登录 // Log in an anyonmous user on component render. // On successful login, this fallback component unmounts. useEffect(() =&gt; { logInWithAnonymous(); }, []) return ( &lt;View &gt; {!result.error &amp;&amp; &lt;Text&gt;Please log in&lt;/Text&gt;} &lt;View&gt; {result.pending &amp;&amp; &lt;Text&gt;{JSON.stringify(result.pending)}&lt;/Text&gt;} {result.error &amp;&amp; &lt;Text&gt;{JSON.stringify(result.error)}&lt;/Text&gt;} &lt;/View&gt; &lt;/View&gt; ); }; export default LogIn APP_ID的位置： 调用订阅方法，订阅每一个需要同步的model，这时你的数据改动 import React from 'react'; import { useState, useEffect } from 'react'; import { useRealm } from '@realm/react'; import { WaitForSync} from 'realm'; import { useColorScheme } from '@/hooks/useColorScheme'; import { useQueryN, useCreateAndUpdate, useDelte } from '@/hooks/useRealmNovle'; import ListOfRealmModels from '@/constants/ListOfRealmModels'; const realm = useRealm() const ideas: any = useQueryN(ListOfRealmModels.ideas); //此处ideas的值为从本地数据库库中利用 useQuery(&quot;Ideas&quot;)拿出来的值，这个值是带有subscribe方法的。 const tags: any = useQueryN(ListOfRealmModels.tags); const collections: any = useQueryN(ListOfRealmModels.collections); const objects: any = useQueryN(ListOfRealmModels.object); const events: any = useQueryN(ListOfRealmModels.events); const subscribeArray: any = [ideas, tags, collections, objects, events] function subscribeModel(subscribeArray: Array&lt;any&gt;) { // Create an async function so that we can `await` the // promise from `.subscribe()`. subscribeArray.forEach((item, index) =&gt; { const createSubscription = async () =&gt; { await item.subscribe({ name: 'subscribe' + index, behavior: WaitForSync.FirstTime, //When you subscribe to a query's results, the results do not contain objects until synced data is downloaded. When you do need to wait for synced objects to finish downloading, configure the waitForSync option. }); }; createSubscription().catch(console.error); }) } useEffect(() =&gt; { subscribeModel(subscribeArray) }, []); 修改登录方式为邮箱/密码登录 在web的AppService中开启登录方式 配置邮箱验证 说明： 暂时设置为Automatically confirm users ，这样子就不需要额外的验证网页了，方便开发 同理password reset Method设置为 Run a password reset function， 然后设置默认函数（直接点击保存就好了），这个函数虽然无法执行预期的修改功能，但是方便我们开始进行开发，后面可以对这个进行配置。 利用 useEmailPasswordAuth()来进行登录和注册 const { result, logIn, register } = useEmailPasswordAuth(); const loginFunction = async () =&gt; { if (!isLogin) { setIsLogin(true) showSnackbar('请输入账号密码进行登录，谢谢🙏。') return } if (email &amp;&amp; password) { logIn({ email, password }); } else { showSnackbar('账号或者密码为空，请检查，谢谢🙏。') } } const hasEmailErrors = () =&gt; { if (email === '') { return false } return !email.includes('@'); }; const registerFunction = async () =&gt; { if (isLogin) { setIsLogin(false) showSnackbar('请输入账号、密码和用户名进行注册，谢谢🙏。') return } await register({ email, password }); }; useEffect(() =&gt; { //注意：利用useEffect在注册完成后，触发登录操作，用户注册完，以后，还需要登录激活一下。否则就只能在web 的 App users（左侧）--&gt; Users --&gt; Pending 中才能找到 if (result.success &amp;&amp; result.operation === AuthOperationName.Register) { logIn({ email, password }); } }, [result, logIn, email, password]); 关于修改已经存在的文档数据： realm.create('UserData', { //这个对象需要修改完成后的完整集合数据（?存在疑问，需要验证一下) _id: userData._id, userId: userId, tags: [...userData.tags, writeObj], ideas: [...userData.ideas], }, 'modified'); //此为创建数据的方法 await realm.write(() =&gt; { realm.create(&lt;SchemaName&gt;, writeObj) }) 新添加schema的方法 本地添加好model import { BSON, ObjectSchema, Object, List } from &quot;realm&quot;; import { Events } from &quot;./Events&quot;; export class Timelines extends Object&lt;Timelines&gt; { _id!: BSON.ObjectId; name!: string; desc: string = ''; events!: List&lt;Events&gt; ; static schema: ObjectSchema = { name: 'Timelines', properties: { _id: 'objectId', name: {type: 'string', indexed: 'full-text'}, desc: 'string', events: 'Events[]', }, primaryKey: '_id', }; } 将其放到初始化和订阅中 初始化： const schemas: any = [Ideas, Tags, Collections, ObjectOfCollections, Events, **Timelines**, UserData] //处理如果同步远端realm失败的情况，作用，同步失败的报错信息影响用户体验 const syncConfigWithErrorHandling: any = { flexible: true, onError: (_session: any, error: any) =&gt; { console.log(_session) console.log(error); }, //是否是用于给remote初始化schemas？ initialSubscriptions: { update(subs: any, realm: any) { subs.add(realm.objects(**schemas**)); }, }, newRealmFileBehavior: realmAccessBehavior, existingRealmFileBehavior: realmAccessBehavior, } &lt;PaperProvider&gt; &lt;AppProvider id={APP_ID} &gt; &lt;UserProvider fallback={LogIn}&gt; &lt;RealmProvider path='./NovelTagSys.realm' schema={schemas} sync={syncConfigWithErrorHandling} &gt; &lt;Stack&gt; &lt;Stack.Screen name=&quot;(tabs)&quot; options={{ headerShown: false }} /&gt; &lt;Stack.Screen name=&quot;+not-found&quot; /&gt; &lt;/Stack&gt; &lt;/RealmProvider&gt; &lt;/UserProvider&gt; &lt;/AppProvider&gt; &lt;/PaperProvider&gt; 错误：Client attempted a write that is not allowed; it has been reverted fulllog: LOG {&quot;weakInternal&quot;: {Symbol(Realm.WeakSyncSession.external_pointer): {}}} LOG [SyncError: Client attempted a write that is not allowed; it has been reverted] 重新启动远端的 sync 根据文档说明，修改了schema之后，需要 Terminate Sync 之后， 再开始启动 修改新建的 schema 权限，否则前端无法对其进行读写 ","link":"https://DennyWanye.GitHub.io/post/expo-realm-pei-zhi-ben-di-he-yuan-duan-de-shu-ju-ku-jin-xing-tong-bu/"},{"title":"在Expo项目中使用 realm ","content":"一、安装 realm的官方有维护一个realm支持的RN、node、Expo、realm、@realm/react的兼容性图表： https://github.com/realm/realm-js/blob/main/COMPATIBILITY.md npx expo install realm @realm/react Expo 本身不支持 realm， 所以需要用安卓环境来运行： npm install expo-dev-client npx expo run:android 二、 在项目本地运行Realm 配置 ReamlProvider ...more code... import { RealmProvider } from '@realm/react'; import { Ideas } from '@/models/Ideas'; import { Tags } from '@/models/Tags'; import { Collections } from '@/models/Collections'; ...more code... &lt;PaperProvider&gt; //path: 为可设置的安装realm的相对路径 //schema为需要提前创建的document 样式 //isMemory 为是否在内存中运行，是的话，数据只会储存在内存中，反之，会放到本地 &lt;RealmProvider path='./NovelTagSys.realm' schema={[Ideas, Tags, Collections]} inMemory={false}&gt; &lt;ThemeProvider value={colorScheme === 'dark' ? DarkTheme : DefaultTheme}&gt; &lt;Stack&gt; &lt;Stack.Screen name=&quot;(tabs)&quot; options={{ headerShown: false }} /&gt; &lt;Stack.Screen name=&quot;+not-found&quot; /&gt; &lt;/Stack&gt; &lt;/ThemeProvider&gt; &lt;/RealmProvider&gt; &lt;/PaperProvider&gt; 创建models 创建嵌套的 schema的方式： https://www.mongodb.com/docs/atlas/device-sdks/sdk/react-native/model-data/relationships-and-embedded-objects/ 这里有一个问题，就是如何将创建的对象和在组件中需要使用的 interface 类型一致。 import { BSON, ObjectSchema, Object, List } from &quot;realm&quot;; import { TagsTS } from &quot;@/constants/Interface&quot;; import { Tags } from &quot;./Tags&quot;; export class Collections extends Object&lt;Collections&gt; { _id!: BSON.ObjectId; name!: string; desc: string = ''; tags!: List&lt;Tags&gt; | TagsTS; //static primaryKey = '_id'; static schema: ObjectSchema = { name: 'Collections', properties: { _id: 'objectId', name: 'string', desc: 'string', tags: 'Tags[]', }, primaryKey: '_id', }; } CUDP操作 import { useRealm, useQuery } from '@realm/react'; import { Tags } from '@/models/Tags'; const realm = useRealm() const tags = useQuery(Tags); const toUpdate = realm .objects(Tags) .filtered('name == $0', tag.name); //create realm.write(() =&gt; { realm.create(&quot;Tags&quot;, { _id: new BSON.ObjectId(), name: tag.name, type: tag.type, desc: tag.desc, color: tag.color, }) }) //update realm.write(() =&gt; { toUpdate[0].name = tag.name; toUpdate[0].type = tag.type; toUpdate[0].desc = tag.desc; }); //delete const toDelete = realm .objects(Tags) .filtered('name == $0', deleteTagName); realm.write(() =&gt; { realm.delete(toDelete) }) QA 问题一、在 One-to-Many 的 schema 中进行对嵌套的 子schema，传递值的时候，发现如果传递的是相同的数组，会导致其清空数据库中 子schema，对应的值。 如下 Error，我想要将 collectionTags 的值更新到 toUpdate[0].tags 中，但是如果它们相同的话，反而会清除realm中 toUpdate[0].tags 的值。 应该是在将数据库中获取的 子schema 对应的值，需要进行解构赋值操作，才能传给 realm.write 进行更新。 realm.write(() =&gt; { toUpdate[0].name = collectionNmae; toUpdate[0].desc = collectionDesc; toUpdate[0].tags = [...collectionTags]; //需要这样操作一下 }); //以下操作也会清除 toUpdate[0].tags对应数据库中的值 realm.write(() =&gt; { toUpdate[0].name = collectionNmae; toUpdate[0].desc = collectionDesc; // toUpdate[0].tags = [...collectionTags]; toUpdate[0].tags = toUpdate[0].tags; }); Error： LOG toUpdate LOG [{&quot;_id&quot;: [ObjectId], &quot;desc&quot;: &quot;this is a really big pig(changedasni ga )&quot;, &quot;name&quot;: &quot;pig king&quot;, &quot;tags&quot;: [Array]}] LOG toUpdate[0].tags LOG [{&quot;_id&quot;: [ObjectId], &quot;color&quot;: &quot;hsla(87,50%,70%,1)&quot;, &quot;desc&quot;: &quot;猪皮够厚，能挨揍&quot;, &quot;manufacturer&quot;: [Array], &quot;name&quot;: &quot;扛揍&quot;, &quot;type&quot;: &quot;特长&quot;}, {&quot;_id&quot;: [ObjectId], &quot;color&quot;: &quot;hsla(4,50%,70%,1)&quot;, &quot;desc&quot;: &quot;特别能睡，吃完就睡&quot;, &quot;manufacturer&quot;: [Array], &quot;name&quot;: &quot;嗜睡&quot;, &quot;type&quot;: &quot;特长&quot;}, {&quot;_id&quot;: [ObjectId], &quot;color&quot;: &quot;hsla(106,50%,70%,1)&quot;, &quot;desc&quot;: &quot;能进化成天蓬小猪&quot;, &quot;manufacturer&quot;: [Array], &quot;name&quot;: &quot;能进化&quot;, &quot;type&quot;: &quot;可能性&quot;}, {&quot;_id&quot;: [ObjectId], &quot;color&quot;: &quot;hsla(147,50%,70%,1)&quot;, &quot;desc&quot;: &quot;特别能吃特别能吃&quot;, &quot;manufacturer&quot;: [Array], &quot;name&quot;: &quot;暴食II&quot;, &quot;type&quot;: &quot;特长&quot;}, {&quot;_id&quot;: [ObjectId], &quot;color&quot;: &quot;hsla(304,50%,70%,1)&quot;, &quot;desc&quot;: &quot;这只是一个称号&quot;, &quot;manufacturer&quot;: [Array], &quot;name&quot;: &quot;猪猪1号&quot;, &quot;type&quot;: &quot;称号&quot;}, {&quot;_id&quot;: [ObjectId], &quot;color&quot;: &quot;hsla(127,50%,70%,1)&quot;, &quot;desc&quot;: &quot;特别能吃特别能吃特别能吃&quot;, &quot;manufacturer&quot;: [Array], &quot;name&quot;: &quot;暴食III&quot;, &quot;type&quot;: &quot;特长&quot;}] LOG collectionTags LOG [{&quot;_id&quot;: [ObjectId], &quot;color&quot;: &quot;hsla(87,50%,70%,1)&quot;, &quot;desc&quot;: &quot;猪皮够厚，能挨揍&quot;, &quot;manufacturer&quot;: [Array], &quot;name&quot;: &quot;扛揍&quot;, &quot;type&quot;: &quot;特长&quot;}, {&quot;_id&quot;: [ObjectId], &quot;color&quot;: &quot;hsla(4,50%,70%,1)&quot;, &quot;desc&quot;: &quot;特别能睡，吃完就睡&quot;, &quot;manufacturer&quot;: [Array], &quot;name&quot;: &quot;嗜睡&quot;, &quot;type&quot;: &quot;特长&quot;}, {&quot;_id&quot;: [ObjectId], &quot;color&quot;: &quot;hsla(106,50%,70%,1)&quot;, &quot;desc&quot;: &quot;能进化成天蓬小猪&quot;, &quot;manufacturer&quot;: [Array], &quot;name&quot;: &quot;能进化&quot;, &quot;type&quot;: &quot;可能性&quot;}, {&quot;_id&quot;: [ObjectId], &quot;color&quot;: &quot;hsla(147,50%,70%,1)&quot;, &quot;desc&quot;: &quot;特别能吃特别能吃&quot;, &quot;manufacturer&quot;: [Array], &quot;name&quot;: &quot;暴食II&quot;, &quot;type&quot;: &quot;特长&quot;}, {&quot;_id&quot;: [ObjectId], &quot;color&quot;: &quot;hsla(304,50%,70%,1)&quot;, &quot;desc&quot;: &quot;这只是一个称号&quot;, &quot;manufacturer&quot;: [Array], &quot;name&quot;: &quot;猪猪1号&quot;, &quot;type&quot;: &quot;称号&quot;}, {&quot;_id&quot;: [ObjectId], &quot;color&quot;: &quot;hsla(127,50%,70%,1)&quot;, &quot;desc&quot;: &quot;特别能吃特别能吃特别能吃&quot;, &quot;manufacturer&quot;: [Array], &quot;name&quot;: &quot;暴食III&quot;, &quot;type&quot;: &quot;特长&quot;}] 问题二 怎么找到realm的文件 Andriod: 首先用 Andriod Stadio 来打开，并启动文件: expo prebuild 生成 andriod 和 ios 文件夹 安装 gradle : brew install gradle。 注意： 如果你在文件夹 Andriod 下执行这个命令，它会顺手帮你将该文件夹下面的依赖安装好，会花一定的时间。 用Andriod Stadio打开 andriod 文件夹。 在 Andriod Stadio &gt; viwe &gt; Tool Windows &gt; Deveice Explorer 中，找到 realm.path 对应的 .ream 文件，双击/右键鼠标对应文件 &gt; save as ... 保存好文件 用 Realm Stadio 打开对应文件 IOS： 直接用 RealmStadio打开 realm.path 对应的 .ream 文件就行了。 ","link":"https://DennyWanye.GitHub.io/post/zai-expo-xiang-mu-zhong-shi-yong-realm/"},{"title":"React 封装弹窗组建","content":"封装一个弹窗输入，输出组件： 需要注意的点： “React.createElement”最多可提供“2”个，修改组件接受对象 props 为入参。 因为无法利用数组来调动 useState，所以表格的双向绑定的数据和修改方法是从父组件传递过来的。 如下是代码： import { Portal, TextInput, Text, Modal } from 'react-native-paper'; import { StyleSheet, SafeAreaView } from 'react-native'; import { ReactNode } from 'react'; type formItems = { label: string, value: string, setValue: Function, } interface PropsTagEditor { title: string, visible: boolean, formItems: Array&lt;formItems&gt;, submitFun: Function } export default function UseEditTag(Props: PropsTagEditor): ReactNode { const { title, visible, formItems, submitFun } = Props const containerStyle = { backgroundColor: 'white', padding: 20 }; return (&lt;Portal&gt; &lt;Modal visible={visible} onDismiss={() =&gt; submitFun()} contentContainerStyle={containerStyle}&gt; &lt;SafeAreaView&gt; &lt;Text&gt;{title}&lt;/Text&gt; { formItems.map((item, index) =&gt; { return ( &lt;TextInput key={index} label={item.label} value={item.value} onChangeText={text =&gt; item.setValue(text)} mode=&quot;outlined&quot; style={styles.tagInput} /&gt; ) }) } &lt;/SafeAreaView&gt; &lt;/Modal&gt; &lt;/Portal&gt;) } const styles = StyleSheet.create({ tagInput: { marginTop: 10, }, }); ","link":"https://DennyWanye.GitHub.io/post/react-feng-zhuang-dan-chuang-zu-jian/"},{"title":"react native 和 Expo 框架的使用遇到的问题","content":"问题一：CommandError: Required property 'android.package' is not found in the project app.json. This is required to open the app. 原因在 package.json 中缺少 android.package 字段，可以在package.json文件中添加如下属性： &quot;android&quot;: { &quot;package&quot;: &quot;com.yourcompany.yourappname&quot;, &quot;versionCode&quot;: 1 } 问题二：关于 expo-image-picker 的使用方法： import * as ImagePicker from 'expo-image-picker'; //利用 launchImageLibraryAsync 方法来返回一个 uri 资源，让 &lt;Image&gt;来进行显示。 //其launchImageLibraryAsync() 接收一个指定了不同选项的对象。该对象是 ImagePickerOptions //object。我们可以在调用方法时传递对象来指定不同的选项。 //当 allowsEditing 设置为 true 时，用户可以在 Android 和 iOS 上的选择过程中裁剪图片，但不能 //在 Web 上裁剪图片。 const pickImageAsync = async () =&gt; { let result = await ImagePicker.launchImageLibraryAsync({ allowsEditing: true, quality: 1, }) console.log(result) if(!result.canceled) { setSelectImage(result.assets[0].uri) console.log(result); } else { alert('You did not select any image.'); } } //&lt;Image&gt; 中的 source 可以是 图片的相对路径和绝对路径，也可以是url，也可以是 uri &lt;Image source={imageSource} &gt;&lt;/Image&gt; //为了演示 result 对象包含哪些属性，下面是一个结果对象示例： { &quot;assets&quot;: [ { &quot;assetId&quot;: null, &quot;base64&quot;: null, &quot;duration&quot;: null, &quot;exif&quot;: null, &quot;height&quot;: 4800, &quot;rotation&quot;: null, &quot;type&quot;: &quot;image&quot;, &quot;uri&quot;: &quot;file:///data/user/0/host.exp.exponent/cache/ExperienceData/%username%252Fsticker-smash-47-beta/ImagePicker/77c4e56f-4ccc-4c83-8634-fc376597b6fb.jpeg&quot;, &quot;width&quot;: 3200 } ], &quot;canceled&quot;: false } 问题三：构建项目的问题 现在对于expo项目构建的理解： 本地将代码 上传到 云端，并给出对应的配置 云端利用metro来根据配置，来进行构建对应的版本 云端返回对应版本应用的下载链接 构建development 应用 eas --version //确保你已经登录了 eas whoami //生成eas配置,可以生成对应Android和ios平台对应的配置文件 eas.json，此文件生成在项目根目录。 eas init eas build:configure //生成可以链接到本地测试服务器的 expo安装包 //需要在项目目录安装 expo-dev-client 同时，你需要expo的账户用作远程登录 //并且 也需要在全局安装eas-cli npm install expo-dev-client npm install -g eas-cli eas build --profile=development --platform=android //生成可以直接可以安装打开的安装包，没有测试环境 eas build --profile=preview --platform=android 在本地打包： 如果你的电脑已经配置好了java、NDK环境，只需执行 eas build --platform android --profile release --local 报了release相关的错误，请检查eas.json文件中 --&gt; build --&gt; release的设置问题 error 示例: ★ eas-cli@10.1.0 is now available. To upgrade, run npm install -g eas-cli. Proceeding with outdated version. Missing build profile in eas.json: release Error: build command failed. eas.json文件示例： { &quot;cli&quot;: { &quot;version&quot;: &quot;&gt;= 10.0.3&quot; }, &quot;build&quot;: { &quot;development&quot;: { &quot;developmentClient&quot;: true, &quot;distribution&quot;: &quot;internal&quot; }, &quot;preview&quot;: { &quot;distribution&quot;: &quot;internal&quot; }, &quot;production&quot;: {}, &quot;release&quot;: { &quot;android&quot;: { &quot;buildType&quot;: &quot;apk&quot; } } }, &quot;submit&quot;: { &quot;production&quot;: {} } } 有用的文章链接：https://juejin.cn/post/7357292176945184795 问题4: Authentication is required 运行 npx expo run:android 报错 Authentication is required ✖ Failed to create the native project. You may want to delete the `./ios` and/or `./android` directories before trying again. 解决方法： 全局安装 expo脚手架： npm install -g expo-cli 运行 expo whoami 确认是否是登录的状态 运行 ``expo prebuild` link: https://stackoverflow.com/questions/77760368/authentication-required-error-message-when-running-npx-expo-prebuild-in-term 问题5: expo ApiV2Error: Entity Not Authorized. 原因：the problem was that the owner property in app.json did not match the owner for whatever account you're logged into on expo-cli or your expo go app. So just try to check if owner property is correct. 解决： npx expo start --offline ","link":"https://DennyWanye.GitHub.io/post/react-native-he-expo-kuang-jia-de-shi-yong-yu-dao-de-wen-ti/"},{"title":"怎么样使用Tag标签","content":"For work, need to use tag in git to mark a version, so that jenkins can deploy it. 创建并推送一个带备注的标签tag： git tag -a TagName -m ‘useful info’ git push origin TagName 创建轻量级标签（不带备注）： git tag TagName 搜索tag： git tag -l ‘支持正则表达式’ 删除本地tag： git tag -d TagName 删除远程的tag： git push origin -d tag TagName git push origin --delete tag TagName ","link":"https://DennyWanye.GitHub.io/post/how-to-use-tag-in-git/"},{"title":"javascript中 New 的底层实现原理","content":"new 的作用，就是省那么几行代码。（也就是所谓的）。 （1）新建一个对象 （2）设置原型链 （3）让F中的this指向instance，执行F的函数体。 （4）判断F的返回值类型： 如果是值类型，就丢弃它，还是返回instance。 如果是引用类型，就返回这个引用类型的对象，替换掉instance。 function create(Con, ...args){ // 创建一个空的对象 this.obj = {}; // 将空对象指向构造函数的原型链 Object.setPrototypeOf(this.obj, Con.prototype); // obj绑定到构造函数上，便可以访问构造函数中的属性，即this.obj.Con(args) let result = Con.apply(this.obj, args); // 如果返回的result是一个对象则返回 // new方法失效，否则返回 obj return result instanceof Object ? result : this.obj; } 1.总览 图的说明：右下角为图例，红色箭头表示__proto__属性指向、绿色箭头表示prototype属性的指向、棕色实线箭头表示本身具有的constructor属性的指向，棕色虚线箭头表示继承而来的constructor属性的指向；蓝色方块表示对象，浅绿色方块表示函数（这里为了更好看清，Foo()仅代表是函数，并不是指执行函数Foo后得到的结果，图中的其他函数同理）。图的中间部分即为它们之间的联系，图的最左边即为例子代码 2.__proto__属性 首先，我们需要牢记两点：①__proto__和constructor属性是对象所独有的；② prototype属性是函数所独有的。但是由于JS中函数也是一种对象，所以函数也拥有__proto__和constructor属性，这点是致使我们产生困惑的很大原因之一。 第一，这里我们仅留下 proto 属性，它是对象所独有的，可以看到__proto__属性都是由一个对象指向一个对象，即指向它们的原型对象（也可以理解为父对象），那么这个属性的作用是什么呢？它的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的__proto__属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端null（可以理解为原始人。。。），再往上找就相当于在null上取值，会报错（可以理解为，再往上就已经不是“人”的范畴了，找不到了，到此结束，null为原型链的终点），由以上这种通过__proto__属性来连接对象直到null的一条链即为我们所谓的原型链。 其实我们平时调用的字符串方法、数组方法、对象方法、函数方法等都是靠__proto__继承而来的。 3. prototype属性 prototype属性，别忘了一点，就是我们前面提到要牢记的两点中的第二点，它是函数所独有的，它是从一个函数指向一个对象。它的含义是函数的原型对象，也就是这个函数（其实所有函数都可以作为构造函数）所创建的实例的原型对象，由此可知：f1.proto === Foo.prototype，它们两个完全一样。那prototype属性的作用又是什么呢？它的作用就是包含可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法。任何函数在创建的时候，其实会默认同时创建该函数的prototype对象。 4. constructor属性 constructor属性也是对象才拥有的，它是从一个对象指向一个函数，含义就是指向该对象的构造函数，每个对象都有构造函数（本身拥有或继承而来，继承而来的要结合__proto__属性查看会更清楚点，如下图所示），从上图中可以看出Function这个对象比较特殊，它的构造函数就是它自己（因为Function可以看成是一个函数，也可以是一个对象），所有函数和对象最终都是由Function构造函数得来，所以constructor属性的终点就是Function这个函数。 这里解释一下上段中“每个对象都有构造函数”这句话。这里的意思是每个对象都可以找到其对应的constructor，因为创建对象的前提是需要有constructor，而这个constructor可能是对象自己本身显式定义的或者通过__proto__在原型链中找到的。而单从constructor这个属性来讲，只有prototype对象才有。每个函数在创建的时候，JS会同时创建一个该函数对应的prototype对象，而函数创建的对象.__proto__ === 该函数.prototype，该函数.prototype.constructor===该函数本身，故通过函数创建的对象即使自己没有constructor属性，它也能通过__proto__找到对应的constructor，所以任何对象最终都可以找到其构造函数（null如果当成对象的话，将null除外）。如下： 5. 总结 总结一下： 我们需要牢记两点：①__proto__和constructor属性是对象所独有的；② prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有__proto__和constructor属性。 __proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，一直找，直到__proto__属性的终点null，再往上找就相当于在null上取值，会报错。通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链。 prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.proto === Foo.prototype。 constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。 本文就此结束了，希望对那些对JS中的prototype、__proto__与constructor属性有困惑的同学有所帮助。 function inherit( Child, Parent ) { // 继承原型上的属性 Child.prototype = Object.create(Parent.prototype) // 修复 constructor Child.prototype.constructor = Child // 存储超类 Child.super = Parent // 静态属性继承 if (Object.setPrototypeOf){ // setPrototypeOf es6 Object.setPrototypeOf(Child, Parent) } else if (Child.__proto__) { // __proto__ es6 引入，但是部分浏览器早已支持 Child.__proto__ = Parent } else { // 兼容 IE10 等陈旧浏览器 // 将 Parent 上的静态属性和方法拷贝一份到 Child 上，不会覆盖 Child 上的方法 for (var k in parent) { if( Parent.hasOwnProperty(k) &amp;&amp; !(k in Child)) { Child[k] = Parent[k] } } } } 很好的一篇说明文章 Javascript继承机制的设计思想 ","link":"https://DennyWanye.GitHub.io/post/javascript-zhong-new-de-di-ceng-shi-xian-yuan-li/"},{"title":"js的事件冒泡和捕获机制","content":"最近面试总是被问到这个问题，然后自己记性也不好，所以做一下总结： 事件冒泡：结构上（非视觉上）嵌套关系的元素，会存在冒泡的功能，即同一事件，自子元素冒泡向父元素。（自底向上） 事件捕获：结构上（非视觉上）嵌套关系的元素，会存在事件捕获的功能，即同一事件，自父元素捕获至子元素（事件源元素）。（自顶向下）（ie没有捕获事件） 触发顺序：先捕获，后冒泡 focus，blur，change，submit，reset，select等事件不冒泡 addEventLinstener: 三个参数： 参数1： 事件的触发方法 参数2： 事件的触发函数 参数3： 是否冒泡： false为冒泡时触发，true为捕获时触发。 阻止冒泡： 1、w3c标准 event.stopPropagation();但ie9以下版本不支持 2、ie独有：event.cancelBubble = true; 通用的写法： inner.addEventListener('click',function(e){ if (e.stopPropagation){ e.stopPropagation(); }else{ e.cancelBubble = true; } console.log('inner111') },false) 阻止默认事件： 默认事件 —— 表单提交，a标签跳转，右键菜单等。 1、return false;以对象属性的方式注册的事件才生效 2、event.preventDefault();w3c标准，ie9以下不兼容 3、event.returnValue = false;兼容ie 事件委托 利用事件冒泡和事件源对象进行处理 优点： 1、性能 不需要循环所有的元素一个个绑定事件 2、灵活 当有新的子元素时不需要重新绑定事件 ","link":"https://DennyWanye.GitHub.io/post/js-de-shi-jian-mou-pao-he-bu-huo-ji-zhi/"},{"title":"React: Refs 转发/回调 Refs","content":"之前一直不理解如何在React中，将类组件和函数组件之间进行Ref转发。 Refs 转发 以下是对上述示例发生情况的逐步解释： 我们通过调用 React.createRef 创建了一个 React ref 并将其赋值给 ref 变量。 我们通过指定 ref 为 JSX 属性，将其向下传递给 。 React 传递 ref 给 forwardRef 内函数 (props, ref) =&gt; ...，作为其第二个参数。 我们向下转发该 ref 参数到 ，将其指定为 JSX 属性。 当 ref 挂载完成，ref.current 将指向 DOM 节点。 代码： import React, {forwardRef, useEffect, Component, useRef} from 'react' function App() { //1. 我们通过调用 React.createRef 创建了一个 React ref 并将其赋值给 ref 变量。 const BtnRef = useRef() //5. 当 ref 挂载完成，ref.current 将指向 &lt;button&gt; DOM 节点。 console.log(BtnRef) return ( &lt;div className=&quot;App&quot;&gt; &lt;header className=&quot;App-header&quot;&gt; //2. 我们通过指定 ref 为 JSX 属性，将其向下传递给 &lt;FancyButton ref={ref}&gt;。 &lt;FancyButton ref={BtnRef} children=&quot;我是一个按钮&quot;&gt;&lt;/FancyButton&gt; &lt;/header&gt; &lt;/div&gt; ) } //3. React 传递 ref 给 forwardRef 内函数 (props, ref) =&gt; ...，作为其第二个参数。 const FancyButton = React.forwardRef((props, ref) =&gt; ( //4. 我们向下转发该 ref 参数到 &lt;button ref={ref}&gt;，将其指定为 JSX 属性。 &lt;button ref={ref} className=&quot;FancyButton&quot;&gt; {props.children} &lt;/button&gt; )); //在类组件中用 React.createRef(); class App extends Component { constructor(props) { super(props); //1. 我们通过调用 React.createRef 创建了一个 React ref 并将其赋值给 ref 变量。 this.BtnRef = React.createRef(); } componentDidMount() { // 5. 当 ref 挂载完成，ref.current 将指向 &lt;button&gt; DOM 节点。 console.log(this.BtnRef) } render() { return ( &lt;div className=&quot;App&quot;&gt; &lt;header className=&quot;App-header&quot;&gt; //2. 我们通过指定 ref 为 JSX 属性，将其向下传递给 &lt;FancyButton ref={ref}&gt;。 &lt;FancyButton ref={this.BtnRef} children=&quot;我是一个按钮&quot;&gt;&lt;/FancyButton&gt; &lt;/header&gt; &lt;/div&gt; ) } } export default App 回调 Refs React 也支持另一种设置 refs 的方式，称为“回调 refs”。 不同于传递 createRef() 创建的 ref 属性，你会传递一个函数。这个函数中接受 React 组件实例或 HTML DOM 元素作为参数，以使它们能在其他地方被存储和访问。 简单的来说，就是你传递一个函数到 ref={callback} 中，callback函数的参数即为当前ref所在的DOM节点。 class CustomTextInput extends React.Component { constructor(props) { super(props); this.textInput = null; //当前参数就是目标DOM对象 this.setTextInputRef = element =&gt; { this.textInput = element; }; this.focusTextInput = () =&gt; { // 使用原生 DOM API 使 text 输入框获得焦点 if (this.textInput) this.textInput.focus(); }; } componentDidMount() { // 组件挂载后，让文本框自动获得焦点 this.focusTextInput(); } render() { // 使用 `ref` 的回调函数将 text 输入框 DOM 节点的引用存储到 React // 实例上（比如 this.textInput） return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref={this.setTextInputRef} /&gt; &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick={this.focusTextInput} /&gt; &lt;/div&gt; ); } } 关于回调 refs 的说明：如果 ref 回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数 null，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的。 ","link":"https://DennyWanye.GitHub.io/post/react-refs-zhuan-fa/"},{"title":"Npx概述","content":"最近遇到了 npx 的安装命令，就对其资料进行了查找阅读，以下是总结： 什么时npx？ 概述： npx是一个工具，它是npm v5.2.0引入的一条命令（npx），是npm的一个包执行器，它可以提高从npm注册表使用软件包的体验 。 npm使得它非常容易地安装和管理托管在注册表上的依赖项， npx使得使用CLI工具和其他托管在注册表。 就像npm极大地提升了我们安装和管理包依赖的体验，在npm的基础之上，npx让npm包中的命令行工具和其他可执行文件在使用上变得更加简单。它极大地简化了我们之前使用纯粹的npm时所需要的大量步骤。 参考链接：使用以及原理 ","link":"https://DennyWanye.GitHub.io/post/npx-gai-shu/"},{"title":"React 组合 和 Context","content":"一、组合 对于有些组件（例如：A）无法提前知晓它们子组件的具体内容，我们可以将其中 无法知晓的内容作为由外部传入的参数（例如：组件B） funciont ComponentC (props) { return &lt;ComponentA&gt;{props.componentB}&lt;/ComponentA&gt; } 对于上述情况，可以称组件C为组件A的特殊实例。 二、对于Context的使用 Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。 基本使用：参考React文档 如果你只是想避免层层传递一些属性，组合（即 一 ）有时候是一个比 context 更好的解决方案。 React.createContext const MyContext = React.createContext(defaultValue); 创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。 只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。此默认值有助于在不使用 Provider 包装组件的情况下对组件进行测试。注意：将 undefined 传递给 Provider 的 value 时，消费组件的 defaultValue 不会生效。 useContext Hook const value = useContext(MyContext); 接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 `` 的 value prop 决定。 ","link":"https://DennyWanye.GitHub.io/post/react-zu-he/"},{"title":"react-helmet：解决单页面应用SEO问题","content":" 一、单页面SEO问题 单页应用一直有一个令人诟病的问题就是就是其对搜索引擎不友好。 究其原因，就是单页应用核心就是 JavaScript 应用，而一般的搜索引擎都只在乎你页面的 HTML 而对于其中的 JavaScript 是不会执行的。 虽然 Google 曾经表示会抓取单页应用（对 Ajax 的结果进行缓存），但是现在已经表示已经不再支持了。 在 Google 中搜索 Angular 应用，只能显示一个可怜的标题(2017-6-15) 难道单页应用就是不能实现 SEO 吗？并不是，还是可以通过一种名叫 Server-side rendering （服务器端预渲染）的方式来实现的。 二、react-snapshot &amp; react-helmet 想调用 React 的 Server-side Rendering 的 API 的话，最简单的方法是使用 react-snapshot。 它和 creat-react-app（一个类似 Angular Cli 的命令行工具）整合得很好，只需要将 render() 替换成 React-Snaport 提供的 render() 即可。它会在 Developer Mode 的时候调用 Render.render() 和之前一样；在 Production Mode 的时候调用 ReactDomServer.toSting()。 在运行 react-scripts build 后再运行 react-snapshot，就会开启一个爬虫，将所以的页面遍历一遍后，导出至 HTML。 运行结果： 使用 w3m 访问 About 页面的结果： 同时也保留了单页应用不需要重复加载的优点： 原理： 原理是什么？每一个单页应用都有一个 index.html 作为的入口。 而使用了 react-snapshot 之后你的单页应用相当于有了同时多个不同入口，或者说你同时拥有了复数多个功能相同的单页应用。 结论： 如果说 react-snapshot 让你的单页应用里的 body 标签搜索引擎可见的话，那 react-helmet 就可以让你的单页应里的 head 标签能被搜索引擎爬到了。 而 head 中的 meta 标签更是 SEO 的关键之一，通过它我们可以主动给爬虫提供重要的信息，例如文章的作者，发布时间等。 Github 地址 使用例子 ","link":"https://DennyWanye.GitHub.io/post/react-helmetjie-jue-dan-ye-mian-ying-yong-seo-wen-ti/"},{"title":"Tip","content":"用_id在MongoDB的compass工具中查询，对应的数据 {&quot;_id&quot;: ObjectId(&quot;5afd7034608b2600280d0f29&quot;)} scss 混合 @mixin center($widthCenter) { width: $widthCenter; margin: 0 auto; } @mixin flex($justify,$row:row,$align: none) { display: flex; flex-direction: $row; justify-content: $justify; @if $align != none { align-items: $align; } } 滚动条长度 let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop; input修改placeholder .xjp-login form .xjp-login-text input::-webkit-input-placeholder { font-size: .28rem; font-family: Arial; font-weight: bold; color: white; text-align: center; } .xjp-login form .xjp-login-text input::-moz-placeholder { /* Mozilla Firefox 19+ */ font-size: .28rem; font-family: Arial; font-weight: bold; color: white; text-align: center; } .xjp-login form .xjp-login-text input:-moz-placeholder { /* Mozilla Firefox 4 to 18 */ font-size: .28rem; font-family: Arial; font-weight: bold; color: white; text-align: center; } .xjp-login form .xjp-login-text input:-ms-input-placeholder { /* Internet Explorer 10-11 */ font-size: .28rem; font-family: Arial; font-weight: bold; color: white; text-align: center; } title &lt;title&gt;PerpetualStar&lt;/title&gt; 获取url参数 /* 获取URL中的参数 */ function getUrlParam(name) { let reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;); //构造一个含有目标参数的正则表达式对象 let r = window.location.search.substr(1).match(reg); //匹配目标参数 if (r != null) return unescape(r[2]); return null; //返回参数值 } input的内容验证（数字，邮箱） &lt;input type=&quot;text&quot; placeholder=&quot;Enter your phone&quot; minlength=&quot;10&quot; maxlength=&quot;10&quot; required=&quot;&quot; onkeyup=&quot;if(this.value.length==1){this.value=this.value.replace(/[^1-9]/g,'')}else{this.value=this.value.replace(/\\D/g,'')}&quot; onafterpaste=&quot;if(this.value.length==1){this.value=this.value.replace(/[^1-9]/g,'')}else{this.value=this.value.replace(/\\D/g,'')}&quot;&gt; $('input[type=number]').keypress(function(e) { if ((!String.fromCharCode(e.keyCode).match(/[0-9.]/))) { return false; } }); $('input[type=number]')[0].oninput = function(e) { if (e.target.value.length &gt; 10) { e.target.value = e.target.value.slice(0, 10) } } //判断邮箱的正则 let pattern = /^([A-Za-z0-9_\\-\\.])+\\@([A-Za-z0-9_\\-\\.])+\\.([A-Za-z]{2,4})$/; if (!pattern.test(email)) { popInfo('Please enter correct email information') return } ajax请求 http://api.youbetterbuy.com $.post('http://api.youbetterbuy.com/api/consultaion/addConsultaionUser',params,function (res) { if(res.retCode === 0) { $.cookie('phonenum', phone, { expires: 7, path: '/' }); closeShade() closeSign() ifCookieGetInfo() isDraw = false }else { if(res.message){ popInfo(res.message); }else { popInfo('System Error.'); } isDraw = false } }) what's up 随机取值 let halfUrl = 'http://yd2.xbetterbuy.com/wame.html?num=' let Arr = [&quot;+918732892814&quot;, &quot;+918939704559&quot;, &quot;+918939704535&quot;, &quot;+918939704614&quot;]; let n = Math.floor(Math.random() * Arr.length + 1) - 1; 条点验证码 &lt;script src=&quot;./js/captcha-mini.js&quot;&gt;&lt;/script&gt; let captcha2 = new CaptchaMini({ lineWidth: 1, //线条宽度 lineNum: 0, //线条数量 dotR: 2, //点的半径 dotNum: 25, //点的数量 preGroundColor: [10, 80], //前景色区间 backGroundColor: [150, 250], //背景色区间 fontSize: 40, //字体大小 fontFamily: ['Georgia', '微软雅黑', 'Helvetica', 'Arial'], //字体类型 fontStyle: 'fill', //字体绘制方法，有fill和stroke content: 'QWERTYUIOPASDFGHJKLZXCVBNM', //验证码内容 length: 6 //验证码长度 }); captcha2.draw(document.querySelector('#captcha2'), r =&gt; { codeImgCheckLogin = r }); layUI的提示消息=============== &lt;script src=&quot;../public_package/layer/layer.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; /*提示消息 */ function popInfo(str) { layer.open({ content: str, skin: 'msg', time: 2 }); } 判断username只为数字，字母，空格，下划线 /*判断username只为数字，字母，空格，下划线*/ function checkUsernaem( username, isSignup=true) { let usern = /^[a-zA-Z0-9_ ]{1,}$/; if (!usern.test(username)) { if(isSignup) { popTip(usernameErrorTip, 'red', true) } username.value = ''; return } } JS获取前一个访问页面的URL地址document.referrer 让弹窗在页面中居中 position: fixed; top: 50%; left: 50%; transform: translateX(-50%) translateY(-50%); meat:vp &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot;&gt; Viewprot：响应式外部设计学习 什么是Viewport？ viewport是用户网页的可是区域。翻译中文就是“视区”，手机浏览器是把页面放在一个虚拟的&quot;窗口&quot;（viewport）中，通常这个虚拟的&quot;窗口&quot;（viewport）比屏幕宽，这样就不用把每个网页挤到很小的窗口中（这样会破坏没有针对手机浏览器优化的网页的布局），用户可以通过平移和缩放来看网页的不同部分。 关于viewport的三个理论？ layout viewport（布局视区）： 在移动端浏览器上面，视觉视区限制了布局视区，为了能在移动设备上正常显示那些为pc端浏览器设计的网站，移动设备上的浏览器都会把自己默认的 viewport 设为980px或其他值，一般都比移动端浏览器可视区域大很多，所以就会出现浏览器出现横向滚动条的情况 。布局视区的宽度是可以用 document.documentElement.clientWidth 来获取。 visual viewport（视觉视区）： 用户透过窗口可以看到的内容区域的大小，用户可以以滑动或者其他的方式来查看页面其他内容，通过 window.screen.width 来获取它的宽度，同样上一张偷来的图，帮助理解。 如何使用viewport 利用 meta 标签设置 viewport &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no&quot;&gt; 各个属性的意思： width：控制 viewport 的大小，可以指定的一个值，如 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。 height：和 width 相对应，指定高度。 initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。 minimum-scale：允许用户缩放到的最大比例。 maximum-scale：允许用户缩放到的最小比例。 user-scalable：用户是否可以手动缩放。 设计图的宽度 = 设备宽度 假如 设计图的宽度为 375px，当然可以是其他的，这里是一个假如，如果是640，750就把375换成对应的数值按照以下方法换算就行就行 因为 375px = 100vw 那么 1px = 100 / 375 vw = 0.26666666666666666vw（约等于） 为了方便计算，放大一百倍，精确到6位，只能下取舍，因为上取舍，计算宽度的时候会大于页面宽度，从而出现滚动条 故： 100px = 26.666666vw（约等于） 又因为给 html 标签设置 font-size 为 26.666666vw （约等于） 1rem为font-size的大小 所以： 1rem = 100px 0.2rem = 20px 也就是说： 设计图上的 12px 换算成rem就是0.12rem，20px就写成0.2rem即可 让字体颜色渐变 font-size: .32rem; font-family:Arial; font-weight:bold; color:rgba(0,0,0,1); background:linear-gradient(0deg,rgba(253,103,87,1) 0%, rgba(255,189,80,1) 100%); -webkit-background-clip:text; -webkit-text-fill-color:transparent; 判断设备是什么硬件平台的 //1.js判断是否为IOS设备 function IsAppleStore() { var u = navigator.userAgent, app = navigator.appVersion; var ios = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/); var iPad = u.indexOf('iPad') &gt; -1; var iPhone = u.indexOf('iPhone') &gt; -1 || u.indexOf('Mac') &gt; -1; if (ios || iPad || iPhone) { return true; } else { return false; } } //1.js判断是否为Android设备 function IsAndroidList() { var u = navigator.userAgent; if (u.indexOf('Android') &gt; -1 || u.indexOf('Adr') &gt; -1) { return true } else { return false } } //3.js判断是否是电脑端 function IsPC() { var userAgentInfo = navigator.userAgent; var Agents = [&quot;Android&quot;, &quot;iPhone&quot;, &quot;SymbianOS&quot;, &quot;Windows Phone&quot;, &quot;iPad&quot;, &quot;iPod&quot;]; var flag = true; for (var v = 0; v &lt; Agents.length; v++) { if (userAgentInfo.indexOf(Agents[v]) &gt; 0) { flag = false; break; } } return flag; } 文本溢出换行 /*单行省略*/ overflow: hidden; //超出的文本隐藏 text-overflow: ellipsis; //溢出用省略号显示 white-space: nowrap; //溢出不换行 /*多行省略*/ word-wrap:break-word; /* 内容存在英语或数字时强制换行 */ overflow: hidden; /* 隐藏溢出部分 */ text-overflow: ellipsis; /* 显示省略符号来代表被隐藏的文本 */ display: -webkit-box; /* 将对象作为弹性伸缩盒子模型显示 */ -webkit-box-orient: vertical; /* 设置盒子内排列顺序为纵向 */ -webkit-line-clamp: 2; /* 限制块元素显示的文本的行数 */ 修改html-webpack-plugin的值 /** * @Description: 自定义配置 * @Author: txf * @CreateDate: 2020/5/7 13:28 */ const path = require(&quot;path&quot;); function resolve(dir) { return path.join(__dirname, dir); } module.exports = { publicPath: process.env.NODE_ENV === &quot;production&quot; ? &quot;/solar/&quot; : &quot;./&quot;, /* 输出文件目录：在npm run build时，生成文件的目录名称 */ outputDir: &quot;dist&quot;, /* 放置生成的静态资源 (json、css、img、fonts) 的 (相对于 outputDir 的) 目录 */ assetsDir: &quot;static&quot;, configureWebpack: { resolve: { alias: { &quot;@&quot;: resolve(&quot;src&quot;) } } }, //修改或新增html-webpack-plugin的值，在index.html里面能读取htmlWebpackPlugin.options.title chainWebpack: config =&gt;{ config.plugin('html') .tap(args =&gt; { args[0].title = &quot;平台&quot;; return args; }) }, /* 是否在构建生产包时生成 sourceMap 文件，false将提高构建速度 */ productionSourceMap: false, lintOnSave: false, }; ","link":"https://DennyWanye.GitHub.io/post/tip/"},{"title":"番茄工作法","content":" 一、番茄工作法的工具： 一个计时工具 一张today's TODO List，包含以下内容： 2.1 小标题，包括时间、地点、人物 2.2 清单，包含今天要做的事情，先后顺序排列 2.3 计划外的紧急事件 activity inventory： 3.1 标题： 人物、事件 3.2 想要做什么的事情 一份记录表，用于记录原始数据。包含：数据、摘要、完成任务所需要的番茄钟时间。 二、法则 规则一： 一个番茄时间共30分钟 = 25分钟工作时间 + 5分钟休息时间 规则二： 一个番茄时间不可分割 规则三：每四个番茄时间后，停止你的工作，进行一次较长时间的休息，15~30分钟 规则四：完成一个任务，划掉一个任务 三、番茄工作法流程 注意： 弄清楚完成某项任务所需要的时间 减少被打断的次数 估测某项任务所需要的时间 线上工具 ","link":"https://DennyWanye.GitHub.io/post/fan-qie-gong-zuo-fa/"},{"title":"EventLoop 和 执行栈","content":"EventLoop 1.堆和栈 堆（heap）：存放这对象 栈（stack）：存放着对象的指针以及一些基础变量类型 2.执行上下文栈（Execution Context Stack），以下简称执行栈。 可以把执行上下文栈认为是一个存储函数调用的栈结构，遵循先进后出的原则 3.执行上下文（Execution Context） 3.1 概念：当你执行一个 函数 的时候，js会生成与之对应的执行环境（Execution Context），然后在这个执行环境中执行该 函数 ，当该 函数 执行完毕并返回结果后，js会退出这个执行环境，并把这个执行环境销毁。 3.2 类型： 全局执行上下文： 这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：1. 创建一个全局对象，在浏览器中这个全局对象就是 window 对象。2. 将 this 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。 函数执行上下文： 每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤，具体过程将在本文后面讨论。 Eval 函数执行上下文： 运行在 eval 函数中的代码也获得了自己的执行上下文，但由于 Javascript 开发人员不常用 eval 函数，所以在这里不再讨论。 4.执行的过程（同步任务） 最开始浏览器执行全局代码的时候，将全局执行上下文压入（push）执行栈的底部。 每当执行一个函数的时候，就会创建该函数的执行上下文，并将它压入到执行栈的底部。当这个函数执行完毕并返回之后，删除（pop）该执行上下文，等待垃圾回收。 浏览器的JS执行引擎总是会访问执行栈顶部的执行上下文。 全局上下文只有一个，在浏览器关闭时出栈。 5.关于异步任务 js引擎遇见一个异步任务之后，并不会阻塞，而是将其挂起，继续执行后续的任务。 然后当异步任务返回结果，并需要执行callback函数的时候。js引擎会将该callback函数放入——事件队列中（Task Queue） 根据异步任务的不同，事件队列也划分成微任务（micro task）队列和宏任务（macro task）队列。 属于宏任务的：setInterval()、setTimeout() 属于微任务的：new Promise()、new MutaionObserver() 主进程的任务执行完成后，会先判断微任务队列是否为空，不为空，则执行其中任务，为空则判断宏任务队列是否为空，不为空则取出最前面的一个任务执行。执行完成后就重复以上操作。 setTimeout(function () { console.log(1); }); new Promise(function(resolve,reject){ console.log(2) resolve(3) }).then(function(val){ console.log(val); }) //执行结果 2 3 1 参考 ","link":"https://DennyWanye.GitHub.io/post/eventloop-he-zhi-xing-zhan/"},{"title":"flex布局的flex-grow、flex-shrink、flex-basis","content":"flex-basis： 用于设置子元素占用的空间。 如果设置为 flex-basis: auto;，子项的宽度由其 width数值决定，如果宽度为 auto，则由其内容撑起的宽度决定。 如果设置为 flex-basis: 700px;，则子项的宽度会被覆盖为700px。 flex-grow：用来“瓜分”父项的“剩余空间”。 根据每个子项flex-grow 的值，来“瓜分”父项的剩余空间。 例子： .father{ width: 500px; height: 30px; display: flex; background-color: #eee; } .children-1 { width: 100px; background-color: pink; } .children-2 { width: 100px; flex-grow: 1; background-color: blue; } .children-3 { width: 100px; flex-grow: 3; background-color: red; } &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;children-1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;children-2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;children-3&quot;&gt;3&lt;/div&gt; &lt;/div&gt; 默认为0，即不参与瓜分 瓜分的份数 = 每个子项flex-grow的数量之和 瓜分的宽度 = 父项未分配出去的宽度，此时为 500 - 300 = 200px 每个子项瓜分到的宽度 = 瓜分的宽度 / 瓜分的份数 * 子项 flex-grow的数量 flex-shrink用来“吸收”超出的空间 .father{ width: 500px; height: 30px; display: flex; background-color: #eee; } .children-1 { width: 300px; flex-basis: 400px; background-color: pink; } .children-2 { width: 100px; flex-basis: 200px; background-color: blue; flex-shrink: 1; } .children-3 { width: 100px; flex-basis: auto; background-color: red; flex-shrink: 2; } 因为flex-basis: 400px覆盖了原本设置的宽度，所以children-1的宽度为 400px。 同理children-2的宽度为200px。 因为flex-basis: auto，所以children-3的宽度为width的宽度，即是100px。 超出的宽度为200px 因为flex-shrink默认值为1，所以子项的flex-shrink值总和为 4。 每个子项所减少的宽度 = 200px / 4 * 每个子项的flex-shrink的值。 [原教程链接](flex-basis： 用于设置子元素占用的空间。 如果设置为 flex-basis: auto;，子项的宽度由其 width数值决定，如果宽度为 auto，则由其内容撑起的宽度决定。 如果设置为 flex-basis: 700px;，则子项的宽度会被覆盖为700px。 flex-grow：用来“瓜分”父项的“剩余空间”。 根据每个子项flex-grow 的值，来“瓜分”父项的剩余空间。 例子： .father{ width: 500px; height: 30px; display: flex; background-color: #eee; } .children-1 { width: 100px; background-color: pink; } .children-2 { width: 100px; flex-grow: 1; background-color: blue; } .children-3 { width: 100px; flex-grow: 3; background-color: red; } &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;children-1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;children-2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;children-3&quot;&gt;3&lt;/div&gt; &lt;/div&gt; 默认为0，即不参与瓜分 瓜分的份数 = 每个子项flex-grow的数量之和 瓜分的宽度 = 父项未分配出去的宽度，此时为 500 - 300 = 200px 每个子项瓜分到的宽度 = 瓜分的宽度 / 瓜分的份数 * 子项 flex-grow的数量 flex-shrink用来“吸收”超出的空间 .father{ width: 500px; height: 30px; display: flex; background-color: #eee; } .children-1 { width: 300px; flex-basis: 400px; background-color: pink; } .children-2 { width: 100px; flex-basis: 200px; background-color: blue; flex-shrink: 1; } .children-3 { width: 100px; flex-basis: auto; background-color: red; flex-shrink: 2; } 因为flex-basis: 400px覆盖了原本设置的宽度，所以children-1的宽度为 400px。 同理children-2的宽度为200px。 因为flex-basis: auto，所以children-3的宽度为width的宽度，即是100px。 超出的宽度为200px 因为flex-shrink默认值为1，所以子项的flex-shrink值总和为 4。 每个子项所减少的宽度 = 200px / 4 * 每个子项的flex-shrink的值 原教程链接 ","link":"https://DennyWanye.GitHub.io/post/flex-bu-ju-de-flex-growflex-shrinkflex-basis/"},{"title":"体内平衡机制","content":" 1. 原理： 我们大脑产生快感和痛感的区域是重叠的，每一次因为多巴胺产生的快感，身体会用自动用一定的痛感来平衡它。在生理学叫做体内平衡。 也就是当你通过行动A产生快感后，体内平衡机制会让你产生以下情况，也即是痛感： 渴望更多 负面的情绪 降低行动A产生的快感强度 如果我们什么都不做，体内平衡会恢复到某种平衡状态。 例子：吸毒，当你吸毒后，会产生巨大的快感。之后会让你想要更多，以及当长时间不吸毒后的戒断反应。戒断反应就是平衡机制产生的痛感（焦虑、烦躁的情绪等）。无限循环之后，产生的痛感就会长时间存在，而吸毒（同样数量和品质的）产生的快感会降低。所以个体就会追求更加刺激的毒品。而当该个体想要戒毒的时候，产生的戒断反应就是痛感的极端表达。 人体内部存在一种平衡，这种平衡起到调节生物体快感和痛感的作用。具体的机制就是：当你做一件事情感觉到快感的之后，体内平衡机制就会产生相应比例（比例是多少呢？）的痛感。反之，当你做一件事情感受到痛感的之后，体内平衡机制就会产生相应比例的快感。 2.这是一种人体的机制（生物体的机制？） 2.1 机制的边界情况 2.1.1多巴胺枯竭 如果不断的追求快感，就会进入一种多巴胺枯竭的状态。从而很难去做一件困难的事情。 例如：如果你早上醒了一直刷抖音，就会很难起床。 2.1.2 体内平衡的机制被打破 就像刚刚说的吸毒，当体内平衡机制被打破时，新的平衡会建立。个体感受到快感的阙值会上升。感受到痛感的阙值会下降。反之如果你一直追求痛感（假设），新的机制平衡建立后，痛感的阙值会上升，快感的阙值会下降。 阙值被打破的条件：（主动或者被动）一直感受到超出体内平衡机制平衡点的快感或痛感，当个体习惯（笼统的说法）了之后，新的平衡被建立。 3.如何利用机制 3.1 追求痛苦 要点：主动做一些会产生痛感的事情，之后根据机制，身体会产生快感。此时，产生的痛感不仅不会产生焦虑，还会缓解焦虑。会产生多巴胺和内啡肽（止痛）产生快感。 3.2 控制快感和痛感的获取 上面一张图为做事情产生的多巴胺数量，喝一杯咖啡为130，最后一项吸食冰毒为1300。红线以下为会破坏机制平衡的。 管理好每天做高快感事情的时间。上图中红线以上的就是正常生活中高多巴胺的行为。如果个体在一天中先做高多巴胺的行为，该个体在之后的一段时间内，就会面临痛感的负面状态（焦虑，烦躁等甚至是多巴胺枯竭），导致很难甚至没有办法完成一些需要去处理且有痛感的事情。 所以，可以先做需要处理且有痛感的事情，之后的时间内因为我们先做了有痛感的事情，我们会得到机制反馈的且能缓解焦虑的快感。 3.3 降低快感的预期 例子：还记得条件反射的实验吗？就是摇铃铛，就给狗子食物吃。实验者最后只是摇铃铛狗都会流出口水。 这就是预期带来的快感，这种快感是没有实际利益的。狗子并没有得到食物，只是听到了铃铛的声音。 所以可以通过降低快感的预期，也即是降低预期带来的快感，从而降低快感的获取。 奖励预判误差 做可以获得快感的行为A，仅仅只是将成功的概率调整到50%，多巴胺即会在行动过程中上升到一个很大的水平，也是赌博之所以吸引力的原因。 所以尽量不要去碰这种涉及到奖励预判误差。 3.4延迟消费多巴胺 当个体被身体驱动去做一些高快感的事情A时，可以通过正念冥想（方法的一种）来暂时放置去做事情A的冲动。 例子：当你在减肥时，睡觉前饿的受不了，非常想要吃东西。可以进行正念冥想，来暂时放置这种想要吃东西的冲动。等待这种冲动慢慢消失。 多巴胺是我们人类寻找未来资源的货币，我们只有认识并管理它，才不会过度消费这个货币。 ————Andrew Huberman 原视频地址 ","link":"https://DennyWanye.GitHub.io/post/ti-nei-ping-heng-ji-zhi/"},{"title":"ReactDnd插件使用","content":"### 一个用ReactDnd库做的一个Demo 主要用到的两个方法：DropTarget DragSource Example.js: import Container from './Container'; import { DndProvider } from &quot;react-dnd&quot;; import { HTML5Backend } from &quot;react-dnd-html5-backend&quot;; export const Example = () =&gt; { return (&lt;DndProvider backend={ HTML5Backend }&gt; &lt;Container /&gt; &lt;/DndProvider&gt;); }; Container.js: import React, { PureComponent } from 'react' import TabItem from &quot;./TabItem&quot;; export default class Container extends PureComponent{ constructor(props) { super(props) this.state = { tabs: [1,2,3,4,5,6,7,8,9,10], } } changeTabLocation = (index, targetIndex) =&gt; { if(this.state.tabs) { const tabs = this.state.tabs let temp = tabs[index] tabs[index] = tabs[targetIndex] tabs[targetIndex] = temp this.setState(tabs) } } renderTabs() { return &lt;TabItem tabs={this.state.tabs} changeTabLocation={this.changeTabLocation.bind(this)} /&gt; } render() { return (&lt;div className=&quot;container&quot;&gt; {this.renderTabs()} &lt;/div&gt;) } } TabItem.js: import React, { PureComponent } from 'react' import { DragSource, DropTarget } from 'react-dnd' import { ItemTypes } from './ItemTypes.js' class ItemCom extends PureComponent { constructor(props) { super(props); } render(){ const { content, connectDropTarget, connectDragSource, isDragging } = this.props const opacity = isDragging ? 0 : 1 return connectDropTarget(connectDragSource(&lt;div style={{ opacity }} className=&quot;tab-item&quot;&gt;{content}&lt;/div&gt;)) } } const dropTarget = DropTarget(ItemTypes.TAB, { drop(props, monitor, component) { if(props.index != monitor.getItem().index) { props.changeTabLocation(props.index, monitor.getItem().index) } console.log(props) console.log(monitor.getItem()) }, },(connect)=&gt; ({ connectDropTarget: connect.dropTarget(), }))(ItemCom) const DargSourceDom = DragSource( ItemTypes.TAB, { beginDrag(props) { const { content, index } = props; return { content, index }; }, }, (connect, monitor) =&gt; ({ connectDragSource: connect.dragSource(), isDragging: monitor.isDragging(), }) )(dropTarget) const TabItem = ({ tabs, changeTabLocation}) =&gt; { return &lt;div&gt; { tabs.map((item,index)=&gt; { return &lt;DargSourceDom index={index} changeTabLocation={changeTabLocation} content={item}/&gt; }) } &lt;/div&gt; } export default TabItem 在 DropTarget 中对于 drop 的处理 对于 DropTarget DragSource 所做的包裹处理。 这两个方法第三个参数都是传到 ItemCom 中的 props 中。 ​ 关于 monitor 中可以监听到的状态 这里有详细的介绍 DragSourceMonitor DropTargetMonitor 。 添加 CustomDragLayer 3.1 添加 CunstomDragLayer import Container from './Container'; import CustomDragLayer from './CustomDragLayer'; import { DndProvider } from &quot;react-dnd&quot;; import {HTML5Backend} from &quot;react-dnd-html5-backend&quot;; export const Example = () =&gt; { return (&lt;DndProvider backend={ HTML5Backend }&gt; &lt;Container /&gt; &lt;CustomDragLayer /&gt; &lt;/DndProvider&gt;); }; CustomDragLayer.js import { DragLayer } from 'react-dnd'; import { ItemTypes } from './ItemTypes'; import { BoxDragPreview } from './BoxDragPreview'; const layerStyles = { position: 'fixed', pointerEvents: 'none', zIndex: 100, left: 0, top: 0, width: '100%', height: '100%', }; function getItemStyles (props) { const { initialOffset, currentOffset } = props if (!initialOffset || !currentOffset) { return { display: 'none' } } let { x, y } = currentOffset y = initialOffset.y const transform = `translate(${x}px, ${y}px)` return { transform: transform, WebkitTransform: transform } } const CustomDragLayer = (props) =&gt; { const { item, itemType, isDragging } = props; function renderItem() { switch (itemType) { case ItemTypes.BOX: return &lt;BoxDragPreview title={item.title}/&gt;; default: return null; } } if (!isDragging) { return null; } return (&lt;div style={layerStyles}&gt; &lt;div style={getItemStyles(props)}&gt;{renderItem()}&lt;/div&gt; &lt;/div&gt;); }; export default DragLayer((monitor,props) =&gt; { return ({ item: monitor.getItem(), itemType: monitor.getItemType(), initialOffset: monitor.getInitialSourceClientOffset(), currentOffset: monitor.getSourceClientOffset(), isDragging: monitor.isDragging(), }) })(CustomDragLayer); 3.2 隐藏原生的拖动动画 import { PureComponent } from 'react'; import { DragSource } from 'react-dnd'; import { getEmptyImage } from 'react-dnd-html5-backend'; import { ItemTypes } from './ItemTypes'; import { Box } from './Box'; function getStyles(props) { const { left, top, isDragging } = props; const transform = `translate3d(${left}px, ${top}px, 0)`; return { position: 'absolute', transform, WebkitTransform: transform, // IE fallback: hide the real node using CSS when dragging // because IE will ignore our custom &quot;empty image&quot; drag preview. opacity: isDragging ? 0 : 1, height: isDragging ? 0 : '', }; } class DraggableBox extends PureComponent { componentDidMount() { const { connectDragPreview } = this.props; if (connectDragPreview) { // Use empty image as a drag preview so browsers don't draw it // and we can draw whatever we want on the custom drag layer instead. connectDragPreview(getEmptyImage(), { // IE fallback: specify that we'd rather screenshot the node // when it already knows it's being dragged so we can hide it with CSS. captureDraggingState: true, }); } } render() { const { title, connectDragSource } = this.props; return connectDragSource(&lt;div style={getStyles(this.props)} role=&quot;DraggableBox&quot;&gt; &lt;Box title={title}/&gt; &lt;/div&gt;); } } export default DragSource(ItemTypes.BOX, { beginDrag(props) { const { id, title, left, top } = props; return { id, title, left, top }; }, }, (connect, monitor) =&gt; ({ connectDragSource: connect.dragSource(), connectDragPreview: connect.dragPreview(), isDragging: monitor.isDragging(), }))(DraggableBox); 3.3 这种CustomDragLayer的核心方法就是 CustomDragLayer.js中的 getItemStyles: function getItemStyles (props) { const { initialOffset, currentOffset } = props if (!initialOffset || !currentOffset) { return { display: 'none' } } let { x, y } = currentOffset y = initialOffset.y //这里的 x y 坐标就是计算出来的 定制化拖动对象坐标 const transform = `translate(${x}px, ${y}px)` return { transform: transform, WebkitTransform: transform } } ","link":"https://DennyWanye.GitHub.io/post/reactdnd-cha-jian-shi-yong/"},{"title":"React.memo()","content":"1.怎么使用 React.memo 是用来决定在何种条件改变下，组件重新渲染。可以减少一次渲染中组件渲染的数量，从而提升用户体验。 React.memo(MyComponent, areEqual) function areEqual () { /* return true if passing nextProps to render would return the same result as passing prevProps to render, otherwise return false */ } MyComponent: 代表的是你需要包裹的组件。 areEqual： 是可选项，判断是否进行渲染的函数，返回值为布尔值。 2.注意项 2.1 当areEqual没有传入的时候，其是比较组件的 props ，来判断组件是否变更，如果变更就进行重新渲染，如果没有就不对该组件进行渲染。 2.2 React.memo的作用原理是判断props是否发生改变（或者是传入的areEqual函数返回的布尔值），如果是true，就重新渲染组件，反之不做其他操作。如果你的组件中有用到 useState, useReducer 或者 useContext Hook的话，当state或者context改变的时候，该组件还是会更新。 2.3 当你向被memo包裹的组件传入回调函数的时候，在每一次渲染时，父组件都会提供一个不同的函数实例，这也就导致此时即使你的其他props数据都相同，但是因为传入的回调函数实例不同，导致每次渲染都会刷新该组件。 原因： function sumNumber() { return (a, b) =&gt; a + b } const sum1 = sumNumber() const sum2 = sumNumber() console.log(sum1 === sum1) //=&gt; true console.log(sum2 === sum2) //=&gt; true console.log(sum1 === sum2) //=&gt; false 此时我们可以用 useCallback来解决 const MemoizedLogout = React.memo(Logout); function MyApp({ store, cookies }) { const onLogout = useCallback( () =&gt; cookies.clear('session'), [cookies] ); return ( &lt;div className=&quot;main&quot;&gt; &lt;header&gt; &lt;MemoizedLogout username={store.username} onLogout={onLogout} /&gt; &lt;/header&gt; {store.content} &lt;/div&gt; ); } ###3.何时使用React.memo 3.1 &quot;Performance-related changes applied incorrectly can even harm performance. Use React.memo() wisely.&quot; 可使用规则： 如果你不能确认性能提升的多少，就不要使用React.memo 3.2 &quot;Performance-related changes applied incorrectly can even harm performance. Use React.memo() wisely.&quot; 一般来说，对于类组件，不建议使用React.memo()。类组件可以使用shouldComponentUpdate()方法，或者对 PureComponent 类组件进行扩展。 3.3 小心无用的比较 React.memo 总是执行两件事： 调用比较函数，来确认props是否发生改变 如果发生了改变就渲染更新该组件，没有就不做渲染 所以当你在错误的地方调用了 React.memo 的时候，也就会错误的调用比较函数，造成性能的浪费。 ","link":"https://DennyWanye.GitHub.io/post/reactmemo/"},{"title":"费曼学习法","content":" 1.确定目标 确认自己对这个目标是否有强烈的动机 2.模拟教学 通过教授他人，教授者对于知识的吸收率达到了90%。 我们可以在博客中写文章，模拟自己教授他人的情况，来近似达到这一目的（存疑？） 注意：学习金字塔不一定是科学的，现在它的出处也无从考究，但它的理念很有启发性。 3.重复回顾 在上述的两个过程中，会产生新的目标（也就是新的问题、发现新的知识盲区等等），此时我们就需要重复上述的步骤，来解决新的目标——通过查找各种资料，将新的目标解决，然后将解决的过程记录并背下来，讲给想象中的小白听，在博客上就是将解决目标的过程梳理成教程记录下来。 注意：重点是需要用自己思考之后的语言表达出来。 4.概念简化 费曼老爷子有一句很经典的话「If I couldn’t reduce it to the freshman level. That means we really don’t understand it.」 将知晓的概念简化， 是用更简单的概念来表达，而不是用更少的语言来表达。 ","link":"https://DennyWanye.GitHub.io/post/fei-man-xue-xi-fa/"},{"title":"舒适区","content":" 每个人都是趋向于舒适区，而且舒适区的范围也会随着主体的适应范围而变。 如果本体一下子步入到舒适区之外太远，本体则会感到极端的不适应、对于本体的成长会非常不利。 如果本体一直在不断的步入舒适区之外，本体也会感到疲倦、难受。 如果本体一直呆在舒适区的范围中，本体会感到无趣乃至生活如一潭死水。 也就意味着： 不应该离开自己的舒适区太远 舒适区对于生活中的困难来说是一个相对性概念。因为本体变强，所以以前觉得困难的事情，现在觉得简单。 一直呆在舒适区中，会变得失去斗志，会变成中年胖大叔。 所以，不要自己变成中年胖大叔，不要自己变成一潭死水，应该： 一点点的探索本体舒适区的极限，当然是在适合自己的感兴趣的方向。 小心温水煮青蛙 ","link":"https://DennyWanye.GitHub.io/post/comfort-zone/"},{"title":"第一次使用Blog","content":" 于2022/2/11第一次使用Gridea做了这个blog（在同事的建议下）。最开始的原因是记录开发中遇见的问题，方便后续的查阅。但现在想一想觉得，也可以记录下来一些自己的所思所想。因为博客的意义是记录 ","link":"https://DennyWanye.GitHub.io/post/first_blog/"}]}